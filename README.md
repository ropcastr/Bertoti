# Engenharia de Software - Prof. Betoti 
Bem-vindo ao meu repositório do curso Tecnológia em Banco de Dados na FATE SJC, exploro conceitos da matéria de engenharia de software. Aqui você vai encontrar minhas impressões, estudos, exemplos práticos e afins. Bora mergulhar nisso?
 
---
 
## Sobre o Projeto  
Esse repositório é um exercício de reflexão sobre as aulas, exercícios, trabahos e interpretações sobre os conteúdos propostos em aula.
 
---
 
## Comentários sobre o Livro Software Engineering at Google, Oreilly  
 
### Trecho 1: O que é Engenharia de Software?  
Neste trecho o livro tenta separar qual a diferença entre só "codar" e ser "engenheiro" de software, tentando mostrar como o software mexe com a vida real, que "programar" é tipo aprender a andar de bicicleta e em contra partida a "engenharia" tem um peso maior, tipo subir de nível, usando a teoria pra criar algo sólido e que não te deixa na mão. O texto ainda faz uma analogia com áreas tipo pontes e aviões, e nos faz pensar sobre a responsabilidade e o peso que temos em mãos, pois se uma ponte cai ou um avião despenca, a coisa fica feia e na minha visão, achei interessante como comparam os engenheiros "clássicos", que seguem regras rígidas pra não derrubar pontes, com programadores que segundo dizem, foram mais relaxados. Como o software tá em tudo hoje (pensa no teu celular ou num Tesla), eles dizem que precisamos de mais rigor e práticas confiáveis!
 
### Trecho 2: Programação ao Longo do Tempo  
O segundo trecho me fez repensar o que é "fazer software". Não é só codar um *Hello World* e pronto — envolve ferramentas e processos pra manter o código vivo por anos. Eles definem engenharia de software como "programação integrada ao longo do tempo", o que achei genial. Tipo, o código é algo que nasce, cresce, muda e até "morre" (quando é aposentado).  
 
O livro foca em três pilares:  
- **Tempo e Mudança**: como o código se adapta ao futuro.  
- **Escala e Crescimento**: como lidar quando o sistema fica gigante.  
- **Trade-offs e Custos**: como decidir o que vale a pena fazer.  
 
Isso me traz a reflexão de que programar pode não ser só técnica, mas também estratégia. Quero ver como o Google aplica isso nos sistemas deles!
 
---
 
## Exemplos de Trade-offs  
Trade-offs são escolhas que a gente faz em engenharia de software, pesando prós e contras. Aqui vão três exemplos que explico com base no que aprendi:
 
1. **Velocidade vs. Qualidade**  
   - *Descrição*: Quer entregar um projeto rápido? Pode mandar um código simples, mas talvez ele vire uma gambiarra difícil de consertar depois. Ou capricha, testa tudo, mas demora mais.  
   - *Exemplo*: Um experimento no Google pode priorizar velocidade, mas depois refatorar pra qualidade.
 
2. **Escalabilidade vs. Simplicidade**  
   - *Descrição*: Tá fazendo um app pequeno? Um banco de dados básico resolve. Mas se ele pode bombar (tipo virar um Instagram), melhor investir numa solução mais complexa desde o início.  
   - *Exemplo*: Começar simples e depois escalar quando o número de usuários explodir.
 
3. **Custo vs. Manutenção**  
   - *Descrição*: Com orçamento curto, usa uma biblioteca barata, mas limitada. Ou gasta mais numa solução sob medida, que facilita ajustes futuros.  
   - *Exemplo*: Economizar agora, mas preparar o bolso pra refazer tudo depois.
 
---
 
## Como Usar Este Repositório  
- **Leia os comentários**: Dá uma olhada nas seções acima pra entender minha visão sobre os trechos do livro.  
- **Explore os trade-offs**: Usa os exemplos como inspiração pra pensar em escolhas no teu próximo projeto.  
- **Contribua**: Se tiver ideias ou quiser discutir, abre uma issue ou manda um pull request!  
 
---
 
## Autor  
Feito por um estudante universitário curioso, tentando entender como o Google transforma código em engenharia de verdade. Qualquer feedback é bem-vindo — afinal, tô aprendendo!  
 
---
 
## Licença  
Esse conteúdo é só uma análise pessoal e não tem fins comerciais. Respeita os direitos do livro *Software Engineering at Google* (O'Reilly) e usa trechos apenas como base pra estudo.
